import sqlite3
import pandas as pd
import streamlit as st
from ydata_profiling import ProfileReport
import streamlit.components.v1 as components

# Function to render ydata_profiling report in Streamlit
def st_profile_report(profile):
    """
    Renders the ydata_profiling report in Streamlit using components.html.

    Parameters:
    - profile: The ProfileReport object generated by ydata_profiling.
    """
    # Generate the HTML report
    profile_html = profile.to_html()

    # Render the HTML in Streamlit
    components.html(profile_html, height=800, scrolling=True)

db_path = "/Users/apple/Documents/Innovations/DataPortal"
# Connect to the Chinook SQLite database using caching to optimize performance
@st.cache_resource
def get_connection(db_path):
    """
    Establishes a connection to the SQLite database.

    Parameters:
    - db_path: Path to the SQLite database file.

    Returns:
    - SQLite connection object.
    """
    conn = sqlite3.connect(db_path, check_same_thread=False)
    return conn

# Establish the database connection
conn = get_connection('Chinook_Sqlite.sqlite')

# Create a cursor object
cursor = conn.cursor()

# Query to list all tables in the database
try:
    cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
    tables = cursor.fetchall()
    table_names = [table[0] for table in tables]
except Exception as e:
    st.error(f"Error fetching table names: {e}")
    table_names = []

# Streamlit app layout
st.title("Chinook Database Viewer")

# Dropdown to select table
selected_table = st.selectbox("Select a table to view", table_names)

# Get the total number of records in the selected table
try:
    cursor.execute(f"SELECT COUNT(*) FROM {selected_table}")
    total_records = cursor.fetchone()[0]
except Exception as e:
    st.error(f"Error fetching record count: {e}")
    total_records = 0

# Slider to select the number of rows (limit), dynamically based on the total records
row_limit = st.slider(
    "Select number of rows to display",
    min_value=1,
    max_value=min(total_records, 1000) if total_records > 0 else 1,  # Limit max_value to 1000 to prevent performance issues
    value=min(10, total_records) if total_records > 0 else 1,
    step=1
)

# Fetch data from the selected table with dynamic limit
try:
    query = f"SELECT * FROM {selected_table} LIMIT {row_limit}"
    df = pd.read_sql_query(query, conn)
except Exception as e:
    st.error(f"Error fetching data: {e}")
    df = pd.DataFrame()

# Display the data in a table format
st.write(f"Showing data from table: **{selected_table}**, limited to **{row_limit}** rows.")
st.dataframe(df)

# Separator for SQL query editor
st.markdown("---")

# Add a SQL query editor
st.subheader("SQL Query Editor")

# Text area for SQL query input
default_query = "SELECT * FROM customers LIMIT 10" if 'customers' in table_names else f"SELECT * FROM {selected_table} LIMIT 10"
user_query = st.text_area("Write your SQL query below:", default_query, height=150)

# Button to execute the query
if st.button("Run Query"):
    with st.spinner("Executing query..."):
        try:
            # Execute the user's SQL query and fetch the results
            query_result_df = pd.read_sql_query(user_query, conn)

            # Display the query result in a table format
            st.success("Query executed successfully!")
            st.write("### Query Results:")
            st.dataframe(query_result_df)

            # Generate and display the EDA report
            if not query_result_df.empty:
                st.write("### Automated EDA Report")
                profile = ProfileReport(query_result_df, title="EDA Report", explorative=True)
                st_profile_report(profile)
            else:
                st.warning("The query returned an empty result set.")
        except Exception as e:
            st.error(f"Error executing query: {e}")


